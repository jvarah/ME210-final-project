<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Team Hunger Games</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="team-hunger-games">Team Hunger Games</h1>
<p>In this report, we discuss the design of our robot for the ME210 Winter 2023 RobOSCARS.</p>
<p>To accomplish the task of delivering good PRESS to our FILM and bad PRESS to our opponent's FILM, we chose to design a line-following robot with a ball-dropping mechanism to deliver the PRESS.</p>
<p>Our report covers the mechanical design, electrical design, state diagrams, and final code.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/robot_picture.jpeg" alt="Hero Shot"></p>
<h1 id="mechanical-designs">Mechanical Designs</h1>
<h2 id="chassis">Chassis</h2>
<p>Our chassis consisted of two layers. The first layer housed the drivetrain and electronics while the second layer housed our batteries and ball dropping mechanism. All chassis components were laser cut out of 1/8&quot; thick duron sheets. T-slots located at each connection point allowed for 4-40 hardware to hold all components together. The chassis breakdown was as follows:</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/chassis-exploded.png" alt="Chassis Exploded View"></p>
<p>Component List:</p>
<p>1: Chassis Top</p>
<p>2: Chassis Bottom</p>
<p>3: Motor Ball Bearing Side Support</p>
<p>4: Motor Face Mount</p>
<p>5: Motor Support</p>
<p>6: Chassis Side Support</p>
<p>All project members were also members of “Stanford Archery” at the time. To show off their club spirit and to add some pizzazz to their design, the Stanford Archery logo was cut into each of the chassis’s side supports.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/chassis-sideSupport.png" alt="Chassis Side Support"></p>
<h2 id="drivetrain">Drivetrain</h2>
<p>Our drivetrain was made from two pairs of differing wheels. The first pair were motor driven wheels that enabled the robot to drive and turn while the second pair were castor wheels that provided stability. These wheel pairs were laid out in the following manner:</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/wheel-layout.jpg" alt="Taped-up wheel"></p>
<p>Our motors were chosen after calculating the minimal torque they needed to produce. For our initial calculations, we assumed that our robot would weigh 5 kg, our wheel radius was 5 cm, and that the maximum acceleration our robot would undergo was 1 m/s^2. Using a FBD approach, we then calculated that for our robot to undergo its maximum acceleration, each motor would need to produce a minimum torque of 0.125 Nm. After checking rm. 36’s stock, we found geared DC motors capable of producing up to 2.16 Nm of torque. As these motors met our required minimum torque requirements, we decided to go ahead and use them.</p>
<p>In order to drive and support the motor driven wheels, the following configuration was used:</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/drivetrain-exploded.png" alt="Drivetrain Exploded View"></p>
<p>Component List:</p>
<p>1: Motor</p>
<p>2: Shaft Coupler</p>
<p>3: Shaft Collar</p>
<p>4: Ball Bearing</p>
<p>5: D-Shaft</p>
<p>6: Wheel</p>
<p>In this configuration, the wheel was rigidly attached to the D-shaft. Power from the motor was transmitted to the wheel by rigidly connecting the D-shaft to the motor through a shaft coupler. Ball bearings and shaft collars were placed on both sides of the wheel to prevent the weight of the robot that the wheel supported from being transferred over to the motor shaft. This was important since non-axial loading would have damaged the motor. To further mitigate this damage source, flexible shaft couplers could have been used. Unfortunately, rm. 36 did not carry any in their stock any and is why flexible shaft couplers were not used in our design.</p>
<p>Each motor was driven by its own L298N motor driver which was in turn driven by an Arduino through PWM. To maximize our motors’ torque output, two full bridges were run in parallel so each motor could maximize the current it could safely pull. We also powered our motors at their highest voltage rating of 12V.</p>
<p>Overall, our drivetrain ran well. During the later stages of testing, our team experienced slipping issues as the wheels wore down, however, by wrapping yellow electrical tape around the motor-driven wheels, this issue was resolved.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/wheel-taped.jpg" alt="Taped-up wheel"></p>
<h2 id="dropping-mechanism">Dropping Mechanism</h2>
<p>To carrry and drop the PRESS balls we designed a simple cylinder type holder with mounts for a servo. The servo, which had a bent paperclip attached to it, served as the gate to hold and selectively drop the PRESS balls. Also mounted to the dropping mechanism was another servo that we used to wave to the paparazzi to indicate the match had begun. To do this we taped the servo to the support and taped a wire to the end of the actuator on the servo.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/dropper.png" alt="Dopper Mech">
<img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/paperclip.png" alt="Paperclip"></p>
<h1 id="electrical-design">Electrical Design</h1>
<p>Our electrical design primarily covers the tape sensing, IR beacon sensing, motor driver, Arduino pinout, and power regulation. The following subsections describes each in further detail.</p>
<h2 id="tape-sensing">Tape Sensing</h2>
<p>For tape sensing, we used four ITR20001/T sensors from Adafruit, which have a paired IR LED and phototransistor in a small housing. Each sensor was configured with a transresistive amplifier with outputs connected straight to the Arduino ADC pins. Below is the schematic for each tape sensor:</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/tape_sensor_TRamp.jpeg" alt="Tape Sensing Schema"></p>
<p>The IR LEDs were always driven on, allowing the Arduino to read a different steady-state analog signal when the tape sensor was above white ground, red tape, and black tape. The transresistive amplifier gain resistor was experimentally chosen to provide sufficient resolution.</p>
<h2 id="ir-beacon-sensing">IR Beacon Sensing</h2>
<p>To detect the IR beacon next to the Studio, we designed a multi-stage filter and amplifier circuit to output a steady-state analog value representing the strength of the square-wave beacon.</p>
<p>The Analog Filter Wizard by ADI was used to aid the design of the multi-stage filters.</p>
<h3 id="high-level-architecture">High Level Architecture</h3>
<p>Below is the high level architecture for the IR beacon sensing. A single phototransistor configured in a transresistive amplifier receives the IR signal, which is passed through a high-pass filter (the prefilter) to remove ambient noise. A switch is used to choose which secondary beacon filter to pass through. The A Filter filters for the 3333Hz beacon, while the B Filter filters for the 909Hz beacon. The siganl is then converted to a steady-state value through the strength detector. Finally, another switch is used to direct the signal to the Arduino ADC pin.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/ir_beacon_architecture.jpeg" alt="IR Beacon Architecture"></p>
<h3 id="transresistive-amplifier-and-prefilter-hpf">Transresistive Amplifier and Prefilter (HPF)</h3>
<p>The first stage of the circuit includes a transresistive amplifier and a high-pass filter. The gain resistor was experimentally chosen to be able to detect the beacon within the Studio. The high-pass filter was designed with a passband above 500Hz and a stopband below 120Hz. A third-order Chebyshev filter was chosen to minimize the number of stages. A DC offset of 2.5V was added to the output of the high-pass filter.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/ir_beacon_TRamp_prefilter.jpeg" alt="IR TRamp Prefilter"></p>
<h3 id="beacon-a-3333hz-filter">Beacon A (3333Hz) Filter</h3>
<p>A cascaded high-pass and low-pass filter was used to filter for Beacon A. The high-pass filter was designed with a stopband below 1kHz to filter out Beacon B. The low-pass filter was designed to attenuate the odd harmonics, with a stopband above 9kHz to filter out the third harmonic.</p>
<p>The third harmonic of Beacon B at 2727Hz posed a design challenge, as this was close to the Beacon A frequency of 3333Hz. A high-order filter would be required to severely attenuate the Beacon B third harmonic while passing the Beacon A fundamental. However, as the desired beacon filter can be chosen with the switch, and the beacons cannot be detected outside of the Studio, this did not pose an issue in the end.</p>
<p>A fourth-order Chebyshev high-pass filter and a fourth-order Chebyshev low-pass filter were chosen to minimize the number of stages. The output of the Beacon A filter is a sinusoidal signal at 3333Hz centered around 2.5V.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/ir_beacon_A_filter.jpeg" alt="IR Beacon A"></p>
<h3 id="beacon-b-909hz-filter">Beacon B (909Hz) Filter</h3>
<p>A low-pass filter was used to filter for Beacon B, as the Prefilter already provides the high-pass filter. A fourth-order Chebyshev filter was chosen for the design. The output of the Beacon B filter is a sinusoidal signal at 909Hz centered around 2.5V.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/ir_beacon_B_filter.jpeg" alt="IR Beacon B"></p>
<h3 id="strength-detector-comparator-and-lpf">Strength Detector (Comparator and LPF)</h3>
<p>In order to detect the strength of the signal, a comparator was used with a threshold set below 2.5V. As the amplitude of the sinusoidal signal increases, the duration of time that the signal is below the threshold also increases, and the duty cycle of the comparator output increases. Finally, to convert to a steady-state analog value, a second-order Butterworth low-pass filter was chosen.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/ir_beacon_strength_detector.jpeg" alt="IR Strength Detector"></p>
<h3 id="completed-protoboard">Completed Protoboard</h3>
<p>The circuit was built using SMD components, several LM324 op amps, and a LM339 comparator on a protoboard using copper tape. As shown in the schematics above, the closest real component values were chosen based on availability. The stages were invidually tested before integration with one another, and the entire circuit was tested on the bench with a mock beacon before integration on the bot.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/ir_beacon_protoboard.jpeg" alt="IR Beacon Protoboard"></p>
<h2 id="motor-driver">Motor Driver</h2>
<p>In order to drive the motors, we used the L298N breakout board from the stockroom. To maximize the current capability, we used one breakout board for each motor in parallel configuration. A 74HC14 inverter was used to simplify logic and reduce the number of signal wires to two: one for direction, and one for PWM enable.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/motor_driver_schematic.jpeg" alt="Motor Driver Schema"></p>
<h2 id="arduino-pinout">Arduino Pinout</h2>
<p>The pinout for the Arduino in the final version of the bot is shown below. The ADC inputs from the IR beacon and tape sensors are located in the bottom left. The motor driver outputs and servo outputs are located on the right side, with pinouts chosen to ensure PWM capability.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/arduino_uno_pinout.jpeg" alt="Arduino Pinout"></p>
<h2 id="power-regulation">Power Regulation</h2>
<p>To power the robot, we wired the two 7.2V NiMH batteries in series for a nominal 14.4V supply. We then used a 20A adjustable buck converter from Amazon to step down to 12V for the motor power supply. For logic power, we used another 3A adjustable buck converter from Amazon to step down from 12V to 5V.</p>
<h1 id="state-diagrams">State Diagrams</h1>
<p>The overall strategy of our robot was to turn towards the IR beacon, stopping when we saw a certain amplitude of the filtered signal, then follow the line towards the bad press, followed by following the line to the good press and depositing two balls at each of those.</p>
<p>Our dispensing mechanism was a tube of four press, with one servo at the bottom which prevented the press from falling out. We could drop two press only by opening and closing the servo at a specific time. Originally, our finite state machines assumed that we would have two servos to form a kind of airlock system, having only one press to drop at a time.</p>
<p>We had also wanted to use an IMU for more consistent turning, but removed it to avoid additional points of failure on our robot. Instead, we turned for approximate amounts of time and depended on sensing the tape.</p>
<p>The following FSMs are our preliminary ones, the final code was streamlined and relied more on timers rather than only sensor inputs.</p>
<h2 id="exiting-studio">Exiting Studio</h2>
<p>For our final code, we did the following:</p>
<ul>
<li>Start in the studio</li>
<li>Turn until the ir beacon reached a threshold</li>
<li>Drive forward for some time (hoping to exit the box surrounded by black tape)</li>
<li>Follow the red tape</li>
</ul>
<p>Original FSM included turning 360 degrees to read the highest IR value, then turn towards it, and then detect the black tape to determine when we had left the studio
<img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/exit-studio.jpg" alt="Exit studio FSM"></p>
<p>The following image is our initial FSM for leaving the studio.</p>
<h2 id="dispensing-press">Dispensing Press</h2>
<p>For our final code, we opened the bottom servo (only one required) for a set number of milliseconds, then closed the servo.</p>
<p>The following image is our initial FSM for dispesning one press
<img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/dispense-press.jpg" alt="Dispensing Press FSM"></p>
<h2 id="line-follow">Line Follow</h2>
<p>Our final code used a simplified approach to line follow:</p>
<ul>
<li>If the difference between left and right line sensors are between a threshold, go forward with half power</li>
<li>Otherwise, if the left reading was more than the right reading (left sensor was over the red tape, right was not), set left motor to 0, right motor to half power to turn left</li>
<li>Otherwise, turn right by setting left motor to half power, right motor to 0</li>
</ul>
<p>Here is our original FSM, which employed P-only closed loop control (using difference between the left/right and center sensors as the error)
<img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/line-follow.jpg" alt="Line Follow FSM"></p>
<h2 id="full-fsm-for-checkoff">Full FSM for Checkoff</h2>
<p>Again, this image is the FSM that references the above state machines, to ultimately complete the goal of dispensing two press in the good press, and then two in the bad press</p>
<p>For our final code, we ended up traveling to the bad press first to throw off opponents who needed the press scales to be level for scoring. We also used timers to replace the gyro, and a simpler line follow method, as described in the line follow section.</p>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/checkoff-fsm.jpg" alt="Final FSM"></p>
<h1 id="code">Code</h1>
<p>Under lib/, we have libraries for each of the main subsystems on our robot. These are abstractions so the <code>main.cpp</code> file can easily call methods like <code>getLineFollowPowers()</code> and <code>setLeftPower()</code> rather than worrying about manual calls to <code>analogWrite()</code> or <code>analogRead()</code></p>
<p>All of the FSM logic is in <code>main.cpp</code></p>
<h2 id="file-structure">File Structure</h2>
<pre><code>me210-final-project/
├── lib/
│   ├── Drive/
│   │   ├── Drive.cpp
│   │   └── Drive.h
│   ├── Hopper/
│   │   ├── Hopper.cpp
│   │   └── Hopper.h
│   └── LineFollow/
│       ├── LineDataTypes.h
│       ├── LineFollow.cpp
│       └── LineFollow.h
└── src/
    └── main.cpp
</code></pre>
<h2 id="maincpp">Main.cpp</h2>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Arduino.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Drive.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Hopper.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;LineDataTypes.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;LineFollow.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SPI.h&gt;</span></span>

<span class="hljs-comment">// Setup the hardware timer constants, needs to be before #include</span>
<span class="hljs-comment">// TimerInterrupt</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_TIMER_1 false</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_TIMER_2 true</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_FREQ 1.0  <span class="hljs-comment">// Hz</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimerInterrupt.h&quot;</span></span>

<span class="hljs-comment">// Motor constants</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEFT_MOTOR_DIR_PORT 7</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEFT_MOTOR_EN_PORT 6  <span class="hljs-comment">// 10 stopped working</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> RIGHT_MOTOR_EN_PORT 5</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> RIGHT_MOTOR_DIR_PORT 4</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_LEFT_INVERTED 1   <span class="hljs-comment">// was 0</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_RIGHT_INVERTED 0  <span class="hljs-comment">// was 1</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> FULL_SPEED 127</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_SPEED 64  <span class="hljs-comment">// 64 // Max forward is 127 // originalLy 64 changed by ESL</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> QUARTER_SPEED 48</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_TESTING_DRIVE 0  <span class="hljs-comment">// Set to 1 to test the driving</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> GYRO_PORT 0x28</span>

<span class="hljs-comment">// PID Constants</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TURN_ERROR 1.0  <span class="hljs-comment">// Degrees</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> K_P_TURN 1 / 180.0  <span class="hljs-comment">// Full motor output at the max error (need to do a</span></span>
<span class="hljs-comment">// full turn)</span>

<span class="hljs-comment">// Tape sensing</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEFT_WING_PORT A2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE_LEFT_PORT A3</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE_RIGHT_PORT A4</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> RIGHT_WING_PORT A5</span>

<span class="hljs-comment">// Measured 3/2/23 at 11:18pm</span>
<span class="hljs-comment">// ~4-5 mm between the bottom of the shielding and the bottom of the tape</span>
<span class="hljs-comment">// sensor, ~3/4 in from bottom of shielding to the floor Using a Vce of 2.5V</span>
<span class="hljs-comment">// with transresistive amplifier, 10k gain resistor, 5V input to LED</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_WHITE_VOLTAGE \
  190  <span class="hljs-comment">// This and below, white surface 3-7-23 after some tape mounting</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_BLACK_VOLTAGE \
  300  <span class="hljs-comment">// This and above, black surface 3-7-23 after some tape mounting</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> CENTER_TO_SIDE_DIFFERENCE \
  MIN_BLACK_VOLTAGE -             \
      MAX_WHITE_VOLTAGE  <span class="hljs-comment">// Difference between center sensor and left/right tape</span></span>
                         <span class="hljs-comment">// sensors when fully centered</span>
<span class="hljs-comment">// #define TURN_K_P 1/180.0 // Full motor output at the max error (need to do a</span>
<span class="hljs-comment">// full turn)</span>

<span class="hljs-comment">// Servo constants</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> HOPPER_BOT_SERVO 11</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INDICATOR_SERVO 3</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVO_MAX_ANGLE 180</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVO_MIN_ANGLE 0</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> IR_BEACON_MIN \
  350  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Test, min value where you know you are facing close enough to</span></span>
       <span class="hljs-comment">// the IR beacon wasa 250, then 300 for checkoff</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE_FOLLOW_UPDATE_FREQ 50 <span class="hljs-comment">// ms</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {
  DRIVE_FORWARD,
  TURN_RIGHT,
  TURN_LEFT,
  STOP,
  DRIVE_BACKWARD,
  NOTHING,
  EXITING_STUDIO,
  DRIVING_STUDIO_TO_GOOD,
  DRIVING_STUDIO_TO_BAD,
  DRIVING_FROM_GOOD_TO_BAD,
  DRIVING_FROM_BAD_TO_GOOD,
  DRIVING_GOOD_TO_STUDIO,
  DISPENSE_TWO_BALLS,
  DISPENSE_ALL_BALLS,
} States_t;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {
  TURNING_TO_IR_BEACON,
  DRIVING_OUT_OF_STUDIO,
  LINE_FOLLOW_UNTIL_LEFT_WING,
  DRIVE_UNTIL_NO_LEFT_WING,
  LINE_FOLLOW_UNTIL_BLACK_TAPE,
  TURNING_180_DEG,
  LINE_FOLLOW_UNTIL_RIGHT_WING,
  TURNING_90_DEG_RIGHT,
  TURNING_90_DEG_LEFT_TO_BAD,
  WAIT_FOR_LINE_FOLLOW_INPUT,
  TURNING_90_DEG_LEFT_TO_GOOD,
  BACKUP,
  DRIVING_PAST_LINE,
  ENTER_STUDIO,
  PERPENDICULAR_PARK,
  PERPENDICULAR_EXIT

  <span class="hljs-comment">// The following states are to get back onto the red line after leaving the</span>
  <span class="hljs-comment">// studio</span>
} Line_follow_states_t;

<span class="hljs-meta">#<span class="hljs-keyword">define</span> ENTER_STUDIO_TIME 1100 <span class="hljs-comment">// was 750 ESL</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BALL_LOAD_TIME 3000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SKIP_RED_LINE_TIME 150</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> { GOOD_PRESS, BAD_PRESS } Score_targets_t;


<span class="hljs-type">static</span> Line_thresholds_t thresholds = {
    <span class="hljs-comment">// LW values</span>
    <span class="hljs-number">132</span>, <span class="hljs-number">370</span>, <span class="hljs-number">280</span>, <span class="hljs-comment">// 3-8-23 at 12am, then 295, then 350</span>
    <span class="hljs-comment">// LL values</span>
    <span class="hljs-number">133</span>, <span class="hljs-number">350</span>, <span class="hljs-number">285</span>, <span class="hljs-comment">// 3-8-23 at 9pm // Was 205, too low when untetheres, was 255, then 285, then 300, was 350 JAV</span>
    <span class="hljs-comment">// LR values</span>
    <span class="hljs-number">131</span>, <span class="hljs-number">350</span>, <span class="hljs-number">290</span>, <span class="hljs-comment">// 3-8-23 at 8pm // Was 205, too low when unteth, was 245, then 275, then 300, was 350 JAV</span>
    <span class="hljs-comment">// RW Values</span>
    <span class="hljs-number">128</span>, <span class="hljs-number">360</span>, <span class="hljs-number">280</span>, <span class="hljs-comment">// Untested, just guess for competition Was 200, then 250, then 295, then 325</span>
};

<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAVE_STUDIO_TIME 100 <span class="hljs-comment">// it was 325 for checkoff // was 200 ESL</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_TURN_DELAY \
  0  <span class="hljs-comment">// Keep the robot straight after aligning with IR beacon</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE_FOLLOW_WAIT \
  1000  <span class="hljs-comment">// Follow line for 2 seconds before checking for wings</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE_FOLLOW_BAD_GOOD_WAIT 2000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TURN_TIME_90_DEG_ONE_HALF_SPD 1400 <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Tune/measure was 563</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TURN_TIME_180_BOTH_MOTORS 900</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TURN_TIME_GOOD_PRESS 1500 <span class="hljs-comment">// Was 600 JAV, then 800 too low</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> K_P_LINE_FOLLOW 0.5 <span class="hljs-comment">// Max diff ~100 units, base power is 0.5, make max error = full power</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE_FOLLOW_BASE_POWER HALF_SPEED * 0.89 <span class="hljs-comment">// 1.1 working, 1.3 too fast, so is 1.25 when at 20 (even 10) sensor slop, 1.15 ok, 1.0 now with grippy</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> BACKUP_TIME 200</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT_TO_DETECT_BLACK 10000 <span class="hljs-comment">// 5 too short, 15 seconds too long</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BACKUP_TIME_GOOD_TO_STUDIO 400</span>

<span class="hljs-type">static</span> States_t state = NOTHING;
<span class="hljs-type">static</span> Line_follow_states_t line_follow_state = WAIT_FOR_LINE_FOLLOW_INPUT;
<span class="hljs-type">static</span> <span class="hljs-type">bool</span> isDriving;
<span class="hljs-type">static</span> Drive drivebase;
<span class="hljs-type">static</span> <span class="hljs-type">double</span> turnTarget = <span class="hljs-number">0.0</span>;
<span class="hljs-type">static</span> LineFollow lineFollow =
    <span class="hljs-built_in">LineFollow</span>(LEFT_WING_PORT, LINE_LEFT_PORT, LINE_RIGHT_PORT, RIGHT_WING_PORT,
               thresholds);

<span class="hljs-comment">// Tunable parameters</span>
<span class="hljs-type">static</span> <span class="hljs-type">double</span> k_p_turn = K_P_TURN;
<span class="hljs-type">static</span> <span class="hljs-type">double</span> turn_max_error = MAX_TURN_ERROR;
<span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> max_white = MAX_WHITE_VOLTAGE;
<span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> min_black = MIN_BLACK_VOLTAGE;
<span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> center_to_side_diff = CENTER_TO_SIDE_DIFFERENCE;

<span class="hljs-meta">#<span class="hljs-keyword">define</span> IR_SENSE_1 A0</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_SERVOS 2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INDICATOR_STEPS 3</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MOVE_INDICATOR_TIME 1000  <span class="hljs-comment">// 5 Seconds</span></span>

<span class="hljs-type">static</span> Servo servo;  <span class="hljs-comment">// Used for all servos</span>
<span class="hljs-type">static</span> Hopper hopper;
<span class="hljs-type">uint8_t</span> hasIndicated = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Will be 2 when it&#x27;s finished</span>

<span class="hljs-type">uint32_t</span> last_time = <span class="hljs-number">0</span>;

Score_targets_t scoring_target;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">driveTest</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleExitStudio</span><span class="hljs-params">(Score_targets_t press_target)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">followLine</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outputSensorVals</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outputStateChanges</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printUpdateAndChange</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> &amp;old, <span class="hljs-type">uint16_t</span> new_val)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printUpdateAndChange</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;old, <span class="hljs-type">double</span> new_val)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleConstantChange</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleStudioToGood</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleStudioToBad</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveIndicator</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleBadToGood</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleGoodToStudio</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Finish getting back to studio</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">9600</span>);
  <span class="hljs-keyword">while</span> (!Serial)
    ;

  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Code started&quot;</span>);

  <span class="hljs-comment">// // Init drivebase</span>
  drivebase = <span class="hljs-built_in">Drive</span>(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_EN_PORT,
                    RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_EN_PORT, GYRO_PORT);

  drivebase.<span class="hljs-built_in">setLeftInverted</span>(IS_LEFT_INVERTED);
  drivebase.<span class="hljs-built_in">setRightInverted</span>(IS_RIGHT_INVERTED);
  isDriving = <span class="hljs-literal">false</span>;

  <span class="hljs-built_in">pinMode</span>(IR_SENSE_1, INPUT);
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Drivebase initialized&quot;</span>);

  <span class="hljs-comment">// Init more values</span>
  hasIndicated = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Will be 2 when it&#x27;s finished</span>
  last_time = <span class="hljs-number">0</span>;
  scoring_target = GOOD_PRESS;

  <span class="hljs-comment">// Indicate</span>
  <span class="hljs-keyword">if</span> (!servo.<span class="hljs-built_in">attach</span>(INDICATOR_SERVO)) {
    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Indicator unable to attach to its pin&quot;</span>);
  }  <span class="hljs-comment">// The port for the ball dropper</span>
  <span class="hljs-comment">// 3 is the indicator servo</span>
  servo.<span class="hljs-built_in">write</span>(SERVO_MAX_ANGLE);
  ITimer2.<span class="hljs-built_in">init</span>();
  ITimer2.<span class="hljs-built_in">setInterval</span>(MOVE_INDICATOR_TIME / INDICATOR_STEPS, moveIndicator,
                      MOVE_INDICATOR_TIME);

  lineFollow.<span class="hljs-built_in">setThresholds</span>(thresholds);
  state = EXITING_STUDIO;
  <span class="hljs-comment">// state = DRIVING_GOOD_TO_STUDIO; // for testing return to studio ESL</span>
  line_follow_state = TURNING_TO_IR_BEACON; <span class="hljs-comment">// for testing return to studio ESL</span>
  <span class="hljs-comment">// line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE; // For line follow testing only</span>
  drivebase.<span class="hljs-built_in">setLeftPower</span>(-QUARTER_SPEED); 
  drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);
  <span class="hljs-comment">// drivebase.setLeftPower(QUARTER_SPEED); // for testing ESL</span>
  <span class="hljs-comment">// drivebase.setRightPower(QUARTER_SPEED);</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Re-attach the servo to the hopper</span>
  <span class="hljs-keyword">if</span> (hasIndicated &gt;= INDICATOR_STEPS &amp;&amp; !hopper.<span class="hljs-built_in">isInitialized</span>()) {
    hopper = <span class="hljs-built_in">Hopper</span>(servo, HOPPER_BOT_SERVO);
  }

  <span class="hljs-comment">// End to end drive test</span>
  <span class="hljs-comment">// if (IS_TESTING_DRIVE &amp;&amp; !isDriving) {</span>
  <span class="hljs-comment">//   isDriving = true;</span>
  <span class="hljs-comment">//   driveTest();</span>
  <span class="hljs-comment">// }</span>

  <span class="hljs-comment">// Test forwards, backwards, left right</span>
  <span class="hljs-comment">// For drive testing (no gyro)</span>
  
  <span class="hljs-keyword">if</span> (Serial.<span class="hljs-built_in">available</span>()) {
    <span class="hljs-type">uint8_t</span> aKey = Serial.<span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">while</span> (Serial.<span class="hljs-built_in">available</span>()) {
      Serial.<span class="hljs-built_in">read</span>();
    }
    Serial.<span class="hljs-built_in">println</span>(aKey);
    <span class="hljs-keyword">switch</span> (aKey) {
      <span class="hljs-comment">// Update values on the fly, only works with the first one</span>
      <span class="hljs-comment">// case 116:  // t for turn error</span>
      <span class="hljs-comment">//   Serial.println(&quot;Input a new value for turn error&quot;);</span>
      <span class="hljs-comment">//   while (!Serial.available())</span>
      <span class="hljs-comment">//     ;</span>
      <span class="hljs-comment">//   double new_error = Serial.parseFloat();</span>
      <span class="hljs-comment">//   printUpdateAndChange(turn_max_error, new_error);</span>
      <span class="hljs-comment">//   break;</span>
      <span class="hljs-comment">// case 112:  // p for turn p</span>
      <span class="hljs-comment">//   Serial.println(&quot;Input a new value for turn p: &quot;);</span>
      <span class="hljs-comment">//   while (!Serial.available())</span>
      <span class="hljs-comment">//     ;</span>
      <span class="hljs-comment">//   double new_p = Serial.parseFloat();</span>
      <span class="hljs-comment">//   printUpdateAndChange(k_p_turn, new_p);</span>
      <span class="hljs-comment">//   break;</span>
      <span class="hljs-comment">// case 119:  // w for white tape thresh</span>
      <span class="hljs-comment">//   Serial.println(&quot;Input a new value for max white: &quot;);</span>
      <span class="hljs-comment">//   while (!Serial.available())</span>
      <span class="hljs-comment">//     ;</span>
      <span class="hljs-comment">//   uint16_t new_white_thresh = Serial.parseInt();</span>
      <span class="hljs-comment">//   printUpdateAndChange(max_white, new_white_thresh);</span>
      <span class="hljs-comment">//   break;</span>
      <span class="hljs-keyword">case</span> <span class="hljs-number">98</span>:  <span class="hljs-comment">// b for backwards</span>
        state = DRIVE_BACKWARD;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(-FULL_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(-FULL_SPEED);
        <span class="hljs-comment">// Serial.println(&quot;Input a new value for min black: &quot;);</span>
        <span class="hljs-comment">// while (!Serial.available())</span>
        <span class="hljs-comment">//   ;</span>
        <span class="hljs-comment">// uint16_t new_black_thresh = Serial.parseInt();</span>
        <span class="hljs-comment">// printUpdateAndChange(min_black, new_black_thresh);</span>
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">99</span>:  <span class="hljs-comment">// c for calibrate</span>
        state = NOTHING;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(HALF_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(HALF_SPEED);

      <span class="hljs-comment">// case 100:  // d for diff</span>
      <span class="hljs-comment">//   Serial.println(&quot;Input a new value for center to side difference: &quot;);</span>
      <span class="hljs-comment">//   while (!Serial.available())</span>
      <span class="hljs-comment">//     ;</span>
      <span class="hljs-comment">//   uint16_t new_center_side_diff = Serial.parseInt();</span>
      <span class="hljs-comment">//   printUpdateAndChange(center_to_side_diff, new_center_side_diff);</span>
      <span class="hljs-comment">//   break;</span>
      <span class="hljs-comment">// Tests for drivebase</span>
      <span class="hljs-keyword">case</span> <span class="hljs-number">108</span>:  <span class="hljs-comment">// l</span>
        state = TURN_LEFT;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(-FULL_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(FULL_SPEED);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">102</span>:  <span class="hljs-comment">// f</span>
        state = DRIVE_FORWARD;
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;forward plz?&quot;</span>);
        drivebase.<span class="hljs-built_in">setLeftPower</span>(FULL_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(FULL_SPEED);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">115</span>:  <span class="hljs-comment">// s</span>
        state = STOP;
        drivebase.<span class="hljs-built_in">stopMotors</span>();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">114</span>:  <span class="hljs-comment">// r</span>
        state = TURN_RIGHT;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(FULL_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(-FULL_SPEED);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">103</span>:                                         <span class="hljs-comment">// g</span>
        drivebase.<span class="hljs-built_in">setGyroOffset</span>(drivebase.<span class="hljs-built_in">getAngle</span>());  <span class="hljs-comment">// Zero the gyro</span>
        <span class="hljs-keyword">break</span>;
      <span class="hljs-comment">// Tests for line follow</span>
      <span class="hljs-keyword">case</span> <span class="hljs-number">101</span>:  <span class="hljs-comment">// e</span>
        state = EXITING_STUDIO;
        line_follow_state = TURNING_TO_IR_BEACON;
        <span class="hljs-comment">// line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE; // For line follow testing only</span>
        drivebase.<span class="hljs-built_in">setLeftPower</span>(-QUARTER_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);


        <span class="hljs-comment">// // Testing only 180</span>
        <span class="hljs-comment">// state = DRIVING_FROM_BAD_TO_GOOD;</span>
        <span class="hljs-comment">// line_follow_state = TURNING_180_DEG;</span>
        <span class="hljs-comment">// drivebase.setLeftPower(-HALF_SPEED);</span>
        <span class="hljs-comment">// drivebase.setRightPower(HALF_SPEED);</span>
        <span class="hljs-comment">// last_time = millis();</span>
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:  <span class="hljs-comment">// d for drop</span>
        hopper.<span class="hljs-built_in">dropTwoBalls</span>();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-comment">// if (state == EXITING_STUDIO) {</span>
  <span class="hljs-comment">//   switch (line_follow_state) {</span>
  <span class="hljs-comment">//     case LINE_FOLLOW_UNTIL_BLACK_TAPE:</span>
  <span class="hljs-comment">//       followLine();</span>
  <span class="hljs-comment">//       break;</span>
  <span class="hljs-comment">//   }</span>
  <span class="hljs-comment">// }</span>

  <span class="hljs-keyword">switch</span> (state) {
    <span class="hljs-keyword">case</span> EXITING_STUDIO:
      <span class="hljs-built_in">handleExitStudio</span>(scoring_target);  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Test Good presss</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> DISPENSE_TWO_BALLS:
      hopper.<span class="hljs-built_in">dropTwoBalls</span>();
      <span class="hljs-keyword">if</span> (scoring_target == BAD_PRESS) {
        state = DRIVING_FROM_BAD_TO_GOOD;
      } <span class="hljs-keyword">else</span> {
        state = DRIVING_GOOD_TO_STUDIO;
      }
      line_follow_state = BACKUP;
      Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Bck up&quot;</span>);
      last_time = <span class="hljs-built_in">millis</span>();
      drivebase.<span class="hljs-built_in">setLeftPower</span>(-HALF_SPEED);
      drivebase.<span class="hljs-built_in">setRightPower</span>(-HALF_SPEED);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> DISPENSE_ALL_BALLS:
      hopper.<span class="hljs-built_in">dropAllBalls</span>();
      state = DRIVING_GOOD_TO_STUDIO;
      line_follow_state = BACKUP;
      Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Bck up&quot;</span>);
      last_time = <span class="hljs-built_in">millis</span>();
      drivebase.<span class="hljs-built_in">setLeftPower</span>(-HALF_SPEED);
      drivebase.<span class="hljs-built_in">setRightPower</span>(-HALF_SPEED);
    <span class="hljs-keyword">case</span> DRIVING_STUDIO_TO_BAD:
      <span class="hljs-built_in">handleStudioToBad</span>();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> DRIVING_STUDIO_TO_GOOD:
      <span class="hljs-built_in">handleStudioToGood</span>();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> DRIVING_FROM_BAD_TO_GOOD:
      <span class="hljs-built_in">handleBadToGood</span>();
      <span class="hljs-keyword">break</span>;

    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Below states for competition</span>
    <span class="hljs-keyword">case</span> DRIVING_GOOD_TO_STUDIO: <span class="hljs-comment">// Not needed for checkoff</span>
      <span class="hljs-built_in">handleGoodToStudio</span>();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-comment">// case WAITING_FOR_GO:</span>
    <span class="hljs-comment">//   // <span class="hljs-doctag">TODO:</span> Something</span>
    <span class="hljs-comment">//   break;</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// Don&#x27;t really care about the other states here</span>
  }

  <span class="hljs-comment">// Periodic print without using Timer2 (which messes with deploying the code)</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">millis</span>() % <span class="hljs-number">1000L</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Serial.println(&quot;Outputting&quot;);</span>
    <span class="hljs-built_in">outputSensorVals</span>();
  }
  <span class="hljs-comment">// outputStateChanges();</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveIndicator</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Serial.println(&quot;Indicating&quot;);</span>
  <span class="hljs-keyword">if</span> (hasIndicated &gt;= INDICATOR_STEPS) {
    <span class="hljs-comment">// Do nothing</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Serial.println(&quot;Movings&quot;);</span>
    <span class="hljs-keyword">if</span> (hasIndicated % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
      servo.<span class="hljs-built_in">write</span>(SERVO_MAX_ANGLE);
    } <span class="hljs-keyword">else</span> {
      servo.<span class="hljs-built_in">write</span>(SERVO_MIN_ANGLE);
    }
    hasIndicated++;
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outputStateChanges</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForBlackTape</span>()) {
    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Found black tape!&quot;</span>);
  }
  <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForLeftWingRed</span>()) {
    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Left wing sensing red&quot;</span>);
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outputSensorVals</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// drivebase.printDebug();</span>
  lineFollow.<span class="hljs-built_in">printDebug</span>();
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IR sensor &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">analogRead</span>(IR_SENSE_1));
  <span class="hljs-comment">// Serial.println(state);</span>
  <span class="hljs-comment">// Serial.println(line_follow_state);</span>
}

<span class="hljs-comment">// Output the change between and old and new value, and overwrite the old value</span>
<span class="hljs-comment">// to be the new one</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printUpdateAndChange</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;old, <span class="hljs-type">double</span> new_val)</span> </span>{
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Old value: &quot;</span>);
  Serial.<span class="hljs-built_in">print</span>(old);
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;New value: &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(new_val);
  old = new_val;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printUpdateAndChange</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> &amp;old, <span class="hljs-type">uint16_t</span> new_val)</span> </span>{
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Old value: &quot;</span>);
  Serial.<span class="hljs-built_in">print</span>(old);
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;New value: &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(new_val);
  old = new_val;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleGoodToStudio</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">switch</span> (line_follow_state) {
    <span class="hljs-keyword">case</span> BACKUP:
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time) &gt; (BACKUP_TIME_GOOD_TO_STUDIO)) {
        drivebase.<span class="hljs-built_in">setLeftPower</span>(-QUARTER_SPEED * <span class="hljs-number">0.75</span>);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED * <span class="hljs-number">0.75</span> * <span class="hljs-number">1.03</span>); <span class="hljs-comment">// changed ESL BRIAN</span>
        last_time = <span class="hljs-built_in">millis</span>();
        line_follow_state = TURNING_90_DEG_LEFT_TO_GOOD;
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> TURNING_90_DEG_LEFT_TO_GOOD:
      <span class="hljs-comment">// Follow line after waiting for a ~180 deg turn</span>
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time &gt; (TURN_TIME_GOOD_PRESS)) &amp;&amp; lineFollow.<span class="hljs-built_in">testForOnLine</span>()) {
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Fllw lw hit&quot;</span>);
        last_time = <span class="hljs-built_in">millis</span>();
        <span class="hljs-comment">// line_follow_state = LINE_FOLLOW_UNTIL_RIGHT_WING;</span>
        line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE;
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LINE_FOLLOW_UNTIL_BLACK_TAPE:
      <span class="hljs-keyword">if</span> (((<span class="hljs-built_in">millis</span>() - last_time) &gt; WAIT_TO_DETECT_BLACK) &amp;&amp; (lineFollow.<span class="hljs-built_in">testForLeftWingBlack</span>() || lineFollow.<span class="hljs-built_in">testForRightWingBlack</span>())) {
        line_follow_state = PERPENDICULAR_PARK; <span class="hljs-comment">// ESL and below commented</span>
        drivebase.<span class="hljs-built_in">stopMotors</span>();
        <span class="hljs-comment">// last_time = millis(); </span>
        <span class="hljs-comment">// line_follow_state = ENTER_STUDIO;</span>
        <span class="hljs-comment">// drivebase.setLeftPower(QUARTER_SPEED*0.95);</span>
        <span class="hljs-comment">// drivebase.setRightPower(QUARTER_SPEED);</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> PERPENDICULAR_PARK: <span class="hljs-comment">// ESL whole case</span>
      <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForLeftWingBlack</span>() &amp;&amp; lineFollow.<span class="hljs-built_in">testForRightWingBlack</span>()) {
        last_time = <span class="hljs-built_in">millis</span>();
        line_follow_state = ENTER_STUDIO;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(QUARTER_SPEED*<span class="hljs-number">0.97</span>);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForLeftWingBlack</span>()) {
        drivebase.<span class="hljs-built_in">setLeftPower</span>(<span class="hljs-number">0</span>);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForRightWingBlack</span>()) {
        drivebase.<span class="hljs-built_in">setLeftPower</span>(QUARTER_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(<span class="hljs-number">0</span>);
      } <span class="hljs-keyword">else</span> {
        drivebase.<span class="hljs-built_in">setLeftPower</span>(QUARTER_SPEED*<span class="hljs-number">0.97</span>);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> ENTER_STUDIO:
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time) &gt; ENTER_STUDIO_TIME) {
        drivebase.<span class="hljs-built_in">stopMotors</span>();
        last_time = <span class="hljs-built_in">millis</span>();
        line_follow_state = WAIT_FOR_LINE_FOLLOW_INPUT;
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> WAIT_FOR_LINE_FOLLOW_INPUT:
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time) &gt; BALL_LOAD_TIME) {
        state = EXITING_STUDIO;
        line_follow_state = TURNING_TO_IR_BEACON;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(-QUARTER_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);
      }
      <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleBadToGood</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">switch</span> (line_follow_state) {
    <span class="hljs-keyword">case</span> BACKUP:
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">millis</span>() - last_time &gt; BACKUP_TIME) {
        drivebase.<span class="hljs-built_in">setLeftPower</span>(-HALF_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(HALF_SPEED);
        last_time = <span class="hljs-built_in">millis</span>();
        line_follow_state = TURNING_180_DEG;
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> TURNING_180_DEG:
      <span class="hljs-comment">// Follow line after waiting for a ~180 deg turn</span>
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time &gt; (TURN_TIME_180_BOTH_MOTORS)) &amp;&amp; lineFollow.<span class="hljs-built_in">testForOnLine</span>()) {
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Line following until left wing hits&quot;</span>);
        last_time = <span class="hljs-built_in">millis</span>();
        line_follow_state = LINE_FOLLOW_UNTIL_LEFT_WING;
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LINE_FOLLOW_UNTIL_LEFT_WING:
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time &gt; LINE_FOLLOW_BAD_GOOD_WAIT) &amp;&amp; lineFollow.<span class="hljs-built_in">testForLeftWingRed</span>()) {
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Turning 90 deg left to good&quot;</span>);
        last_time = <span class="hljs-built_in">millis</span>();
        line_follow_state = TURNING_90_DEG_LEFT_TO_GOOD;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(<span class="hljs-number">0</span>);
        drivebase.<span class="hljs-built_in">setRightPower</span>(HALF_SPEED);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> TURNING_90_DEG_LEFT_TO_GOOD:
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time &gt; TURN_TIME_90_DEG_ONE_HALF_SPD) &amp;&amp; lineFollow.<span class="hljs-built_in">testForOnLine</span>()) {
        line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE;
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Line follow until bad tape at good press&quot;</span>);
        <span class="hljs-built_in">followLine</span>();
      } 
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LINE_FOLLOW_UNTIL_BLACK_TAPE:
      <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForBlackTape</span>()) {
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Got black tape&quot;</span>);
        drivebase.<span class="hljs-built_in">stopMotors</span>();
        line_follow_state = WAIT_FOR_LINE_FOLLOW_INPUT;
        state = DISPENSE_ALL_BALLS;
        scoring_target = GOOD_PRESS; <span class="hljs-comment">// Only score on good press after first attempt</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-comment">/**
 * Exit studio procedure (separate FSM)
 * Will get to the first intersection from starting aligned in the studio
 */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleExitStudio</span><span class="hljs-params">(Score_targets_t press_target)</span> </span>{
  <span class="hljs-keyword">switch</span> (line_follow_state) {
    <span class="hljs-keyword">case</span> TURNING_TO_IR_BEACON:
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">analogRead</span>(IR_SENSE_1) &gt; IR_BEACON_MIN) {
        <span class="hljs-built_in">delay</span>(EXIT_TURN_DELAY);
        drivebase.<span class="hljs-built_in">setLeftPower</span>(HALF_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(HALF_SPEED); <span class="hljs-comment">// CHANGED BY ESL *0.95</span>
        line_follow_state = DRIVING_OUT_OF_STUDIO;
        <span class="hljs-comment">// line_follow_state = PERPENDICULAR_EXIT;</span>
        last_time = <span class="hljs-built_in">millis</span>();
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Exiting studio by driving forward&quot;</span>);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> PERPENDICULAR_EXIT:
      <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForLeftWingBlack</span>() &amp;&amp; lineFollow.<span class="hljs-built_in">testForRightWingBlack</span>()) {
        last_time = <span class="hljs-built_in">millis</span>();
        line_follow_state = DRIVING_OUT_OF_STUDIO;
        drivebase.<span class="hljs-built_in">setLeftPower</span>(QUARTER_SPEED*<span class="hljs-number">0.97</span>);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForLeftWingBlack</span>()) {
        drivebase.<span class="hljs-built_in">setLeftPower</span>(<span class="hljs-number">0</span>);
        drivebase.<span class="hljs-built_in">setRightPower</span>(QUARTER_SPEED);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForRightWingBlack</span>()) {
        drivebase.<span class="hljs-built_in">setLeftPower</span>(QUARTER_SPEED);
        drivebase.<span class="hljs-built_in">setRightPower</span>(<span class="hljs-number">0</span>);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> DRIVING_OUT_OF_STUDIO:
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> if timer expired, stop</span>
      <span class="hljs-comment">// Drive for one second</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">millis</span>() - last_time &gt; LEAVE_STUDIO_TIME) {
        drivebase.<span class="hljs-built_in">stopMotors</span>();
        line_follow_state = LINE_FOLLOW_UNTIL_LEFT_WING;
        last_time = <span class="hljs-built_in">millis</span>();
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Driving until left wing&quot;</span>);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LINE_FOLLOW_UNTIL_LEFT_WING:
      <span class="hljs-comment">// Line follow for a bit before checking the wing too early</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">millis</span>() - last_time &gt; LINE_FOLLOW_WAIT &amp;&amp;
          lineFollow.<span class="hljs-built_in">testForLeftWingRed</span>()) {
        <span class="hljs-comment">// Determine what state to handle depending on the scoring target</span>
        <span class="hljs-keyword">if</span> (press_target == GOOD_PRESS) {
          line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE; <span class="hljs-comment">// Just ignore the tape, keep going</span>
          state = DRIVING_STUDIO_TO_GOOD;
          drivebase.<span class="hljs-built_in">setLeftPower</span>(FULL_SPEED);
          drivebase.<span class="hljs-built_in">setRightPower</span>(FULL_SPEED);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (press_target == BAD_PRESS) {
          state = DRIVING_STUDIO_TO_BAD;
          line_follow_state = TURNING_90_DEG_LEFT_TO_BAD;
          last_time = <span class="hljs-built_in">millis</span>();
          Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Beginning turn left to hit the bad press line&quot;</span>);
          <span class="hljs-comment">// turnTarget = drivebase.getAngle() - 90;</span>
          drivebase.<span class="hljs-built_in">setLeftPower</span>(<span class="hljs-number">0</span>);
          drivebase.<span class="hljs-built_in">setRightPower</span>(HALF_SPEED);
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;

    <span class="hljs-comment">// case LINE_FOLLOW_UNTIL_BLACK_TAPE: // For testing line follow only, set state to LINE_FOLLOW_UNTIL_BLACK_TAPE in main</span>
    <span class="hljs-comment">//   followLine();</span>
    <span class="hljs-comment">//   break;</span>
    <span class="hljs-keyword">default</span>:
      Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Something is not good in exiting studio&quot;</span>);
      <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">followLine</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// if (millis() % LINE_FOLLOW_UPDATE_FREQ == 0) {</span>
    <span class="hljs-comment">// Make it simple, then implement PID</span>
    Motor_powers_t powers = lineFollow.<span class="hljs-built_in">getLineFollowPowers</span>(K_P_LINE_FOLLOW, LINE_FOLLOW_BASE_POWER);
    drivebase.<span class="hljs-built_in">setLeftPower</span>(powers.left_power);
    drivebase.<span class="hljs-built_in">setRightPower</span>(powers.right_power);
  <span class="hljs-comment">// }</span>
}

<span class="hljs-comment">// After getting to the intersection of the tape driving from studio to good</span>
<span class="hljs-comment">// press, get to good press</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleStudioToGood</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">switch</span> (line_follow_state) {
    <span class="hljs-comment">// case DRIVE_UNTIL_NO_LEFT_WING:</span>
    <span class="hljs-comment">//   if (!lineFollow.testForLeftWingRed()) {</span>
    <span class="hljs-comment">//     line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE;</span>
    <span class="hljs-comment">//     followLine();</span>
    <span class="hljs-comment">//   }</span>
    <span class="hljs-comment">//   break;</span>
    <span class="hljs-keyword">case</span> LINE_FOLLOW_UNTIL_BLACK_TAPE:
      <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForBlackTape</span>()) {
        drivebase.<span class="hljs-built_in">stopMotors</span>();
        line_follow_state = WAIT_FOR_LINE_FOLLOW_INPUT;
        state = DISPENSE_ALL_BALLS;
        last_time = <span class="hljs-built_in">millis</span>();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-comment">// After getting to the intersection of the tape driving from studio to bad</span>
<span class="hljs-comment">// press, get to bad press</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleStudioToBad</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">switch</span> (line_follow_state) {
    <span class="hljs-keyword">case</span> TURNING_90_DEG_LEFT_TO_BAD:
      <span class="hljs-comment">// Turned enough to start checking if on line</span>
      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">millis</span>() - last_time &gt; TURN_TIME_90_DEG_ONE_HALF_SPD) &amp;&amp; lineFollow.<span class="hljs-built_in">testForOnLine</span>()) {
        line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE;
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Folw til blk at bad&quot;</span>);
        <span class="hljs-built_in">followLine</span>();
      }
      <span class="hljs-keyword">break</span>;
    
      <span class="hljs-comment">// double turn_error = drivebase.calcTurnError(turnTarget);</span>
      <span class="hljs-comment">// // If turned 90 degrees, follow the line</span>
      <span class="hljs-comment">// if (abs(turn_error) &lt;= turn_max_error) {</span>
      <span class="hljs-comment">//   if (!lineFollow.testForOnLine(max_white, min_black)) {</span>
      <span class="hljs-comment">//     Serial.println(&quot;Turned 90 deg, not on the line, hoping for the</span>
      <span class="hljs-comment">//     best&quot;);</span>
      <span class="hljs-comment">//   }</span>
      <span class="hljs-comment">//   line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE;</span>
      <span class="hljs-comment">//   followLine();</span>
      <span class="hljs-comment">//   // Otherwise, keep turning 90 degrees</span>
      <span class="hljs-comment">// } else {</span>
      <span class="hljs-comment">//   drivebase.setTurnPIDPowers(turnTarget, k_p_turn);</span>
      <span class="hljs-comment">// }</span>

      <span class="hljs-comment">// if (!lineFollow.testForOnLine()) {</span>
      <span class="hljs-comment">//   Serial.println(&quot;Turning 90 deg, not on the line, hoping for the best&quot;);</span>
      <span class="hljs-comment">// } else {</span>
      <span class="hljs-comment">//   line_follow_state = LINE_FOLLOW_UNTIL_BLACK_TAPE;</span>
      <span class="hljs-comment">//   followLine();</span>
      <span class="hljs-comment">// }</span>
    <span class="hljs-keyword">case</span> LINE_FOLLOW_UNTIL_BLACK_TAPE:
      <span class="hljs-keyword">if</span> (lineFollow.<span class="hljs-built_in">testForBlackTape</span>()) {
        Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Drp bad&quot;</span>);
        drivebase.<span class="hljs-built_in">stopMotors</span>();
        state = DISPENSE_TWO_BALLS;
        line_follow_state = WAIT_FOR_LINE_FOLLOW_INPUT;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">followLine</span>();
      }
  }
}

<span class="hljs-comment">// Note: Very bad style, uses delay which stops program execution</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">driveTest</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Drive straight at half speed, then stop</span>
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Going forward&quot;</span>);
  drivebase.<span class="hljs-built_in">setLeftPower</span>(HALF_SPEED);
  drivebase.<span class="hljs-built_in">setRightPower</span>(HALF_SPEED);
  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);  <span class="hljs-comment">// 2 Seconds</span>
  drivebase.<span class="hljs-built_in">stopMotors</span>();
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Stopped motors&quot;</span>);
  <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);

  <span class="hljs-comment">// Turn to (roughly) 90 degrees</span>
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Turning right 90 deg&quot;</span>);
  drivebase.<span class="hljs-built_in">setLeftPower</span>(HALF_SPEED);
  drivebase.<span class="hljs-built_in">setRightPower</span>(-HALF_SPEED);
  <span class="hljs-type">uint8_t</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-type">uint8_t</span> target = <span class="hljs-number">90</span>;
  <span class="hljs-type">double</span> error = <span class="hljs-number">0.0</span>;
  <span class="hljs-keyword">do</span> {
    error = drivebase.<span class="hljs-built_in">calcTurnError</span>(target);
    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) {  <span class="hljs-comment">// Print every 255 cycles</span>
      Serial.<span class="hljs-built_in">println</span>(drivebase.<span class="hljs-built_in">getAngle</span>());
    }
    count++;
  } <span class="hljs-keyword">while</span> (<span class="hljs-built_in">abs</span>(error) &gt;= turn_max_error * <span class="hljs-number">10</span>);
  drivebase.<span class="hljs-built_in">stopMotors</span>();
  <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);

  <span class="hljs-comment">// Turn (roughly) to 45 degrees</span>
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Turning left 45 deg&quot;</span>);
  target = <span class="hljs-number">45</span>;
  drivebase.<span class="hljs-built_in">setLeftPower</span>(-HALF_SPEED);
  drivebase.<span class="hljs-built_in">setRightPower</span>(HALF_SPEED);

  <span class="hljs-comment">// Keep turning until you got there</span>
  <span class="hljs-keyword">do</span> {
    error = drivebase.<span class="hljs-built_in">calcTurnError</span>(target);
    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) {  <span class="hljs-comment">// Print every 255 cycles</span>
      Serial.<span class="hljs-built_in">println</span>(drivebase.<span class="hljs-built_in">getAngle</span>());
    }
    count++;
  } <span class="hljs-keyword">while</span> (<span class="hljs-built_in">abs</span>(error) &gt;= turn_max_error * <span class="hljs-number">10</span>);
  drivebase.<span class="hljs-built_in">stopMotors</span>();
  <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);

  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Full power forward&quot;</span>);
  <span class="hljs-comment">// Drive straight at full power</span>
  drivebase.<span class="hljs-built_in">setLeftPower</span>(FULL_SPEED);
  drivebase.<span class="hljs-built_in">setRightPower</span>(FULL_SPEED);
  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);
}
</code></pre>
<h2 id="drive">Drive</h2>
<h3 id="driveh">Drive.h</h3>
<pre><code class="language-cpp"><span class="hljs-comment">/**
 * Drive.h contains the exposed methods for the drive subsystem
 * Get/set gyro position
 * Set left/right motor
 */</span>

<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> Drive_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> Drive_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Adafruit_I2CDevice.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Adafruit_BNO055.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">Drive</span>(); <span class="hljs-comment">// Allows for drive to be initialized in setup</span>
  <span class="hljs-built_in">Drive</span>(<span class="hljs-type">uint8_t</span> left_dir_port, <span class="hljs-type">uint8_t</span> left_en_port, <span class="hljs-type">uint8_t</span> right_dir_port,
        <span class="hljs-type">uint8_t</span> right_en_port, <span class="hljs-type">uint8_t</span> gyro_prt);
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLeftInverted</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> inverted)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setRightInverted</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> inverted)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLeftPower</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> power)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setRightPower</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> power)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stopMotors</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getAngle</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGyroOffset</span><span class="hljs-params">(<span class="hljs-type">double</span> offset)</span></span>;
  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calcTurnError</span><span class="hljs-params">(<span class="hljs-type">double</span> target_angle)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTurnPIDPowers</span><span class="hljs-params">(<span class="hljs-type">double</span> target_angle, <span class="hljs-type">double</span> k_p)</span></span>; 
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDebug</span><span class="hljs-params">()</span></span>;

 <span class="hljs-keyword">private</span>:
  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLeftInverted</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isRightInverted</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">leftDir</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rightDir</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setRightDir</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLeftDir</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGyroInit</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getGyroInit</span><span class="hljs-params">()</span></span>;
  <span class="hljs-type">uint8_t</span> l_dir_port;
  <span class="hljs-type">uint8_t</span> l_en_port;
  <span class="hljs-type">uint8_t</span> r_dir_port;
  <span class="hljs-type">uint8_t</span> r_en_port;
  <span class="hljs-type">uint8_t</span> gyro_port;

  <span class="hljs-comment">/* Structure of invertsAndState:
    0, 0, 0, gyroInitialized, LeftInverted, RightInverted, LeftDir, RightDir
      */</span>
  <span class="hljs-type">uint8_t</span> inverts_and_states;  <span class="hljs-comment">// Each bit is different info</span>
  Adafruit_BNO055 gyro;
  <span class="hljs-type">double</span> gyro_offset;
};

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<h3 id="drivecpp">Drive.cpp</h3>
<pre><code class="language-cpp"><span class="hljs-comment">/**
 * Drive.cpp is the implementation for the drive subsystem
 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Drive.h&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_EXT_CRYSTAL true</span>

<span class="hljs-comment">/* Structure of invertsAndState:
    0, 0, 0, GyroInit, LeftInverted, RightInverted, LeftDir, RightDir
*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GYRO_INIT_MASK (uint8_t)0b10000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEFT_INVERT_MASK (uint8_t)0b1000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> RIGHT_INVERT_MASK (uint8_t)0b0100</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEFT_DIR_MASK (uint8_t)0b0010</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> RIGHT_DIR_MASK (uint8_t)0b0001</span>

<span class="hljs-comment">// DO NOT CHANGE THESE, bitmasks depend on forward = 0, backward = 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FORWARD (uint8_t)0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BACKWARD (uint8_t)1</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEFT_SCALAR 1.0 <span class="hljs-comment">// was 0.95 ESL</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> RIGHT_SCALAR 0.97 <span class="hljs-comment">// was 0.1 ESL</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> GYRO_DEGREES 360.0  <span class="hljs-comment">// Max value from gyro (0 - 359.9999)</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GYRO_HALF_DEGREES (GYRO_DEGREES / 2)</span>

Drive::<span class="hljs-built_in">Drive</span>() {
  <span class="hljs-comment">// Ports default to garbage values</span>
  inverts_and_states = <span class="hljs-number">0</span>;
}

Drive::<span class="hljs-built_in">Drive</span>(<span class="hljs-type">uint8_t</span> left_dir_port, <span class="hljs-type">uint8_t</span> left_en_port,
             <span class="hljs-type">uint8_t</span> right_dir_port, <span class="hljs-type">uint8_t</span> right_en_port, <span class="hljs-type">uint8_t</span> gyro_prt) {
  <span class="hljs-comment">// State initialization</span>
  inverts_and_states = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Gyro initialization</span>
  gyro_offset = <span class="hljs-number">0</span>;
  gyro_port = gyro_prt;

  <span class="hljs-comment">// // Init gyro to pass to drivebase</span>
  <span class="hljs-comment">// if (!gyro.begin()) {</span>
  <span class="hljs-comment">//   Serial.println(&quot;No gyro detected&quot;);</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-comment">// gyro.setExtCrystalUse(true);</span>
  <span class="hljs-comment">// setGyroInit();</span>

  <span class="hljs-comment">// Motor initialization</span>
  l_dir_port = left_dir_port;
  l_en_port = left_en_port;
  r_dir_port = right_dir_port;
  r_en_port = right_en_port;

  <span class="hljs-built_in">pinMode</span>(l_dir_port, OUTPUT);
  <span class="hljs-built_in">pinMode</span>(l_en_port, OUTPUT);
  <span class="hljs-built_in">pinMode</span>(r_dir_port, OUTPUT);
  <span class="hljs-built_in">pinMode</span>(r_en_port, OUTPUT);
  <span class="hljs-built_in">digitalWrite</span>(l_dir_port, LOW);
  <span class="hljs-built_in">digitalWrite</span>(r_dir_port, LOW);
  <span class="hljs-built_in">analogWrite</span>(l_en_port, LOW);
  <span class="hljs-built_in">analogWrite</span>(r_en_port, LOW);

  <span class="hljs-built_in">setLeftDir</span>(FORWARD);
  <span class="hljs-built_in">setRightDir</span>(FORWARD);
  <span class="hljs-built_in">stopMotors</span>();
}

<span class="hljs-comment">// Set direction of the motors</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setRightDir</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span> </span>{
  <span class="hljs-keyword">if</span> (dir == BACKWARD) {
    inverts_and_states |= RIGHT_DIR_MASK;  <span class="hljs-comment">// Turn on</span>
    <span class="hljs-built_in">digitalWrite</span>(r_dir_port, HIGH);
  } <span class="hljs-keyword">else</span> {
    inverts_and_states &amp;= ~RIGHT_DIR_MASK;  <span class="hljs-comment">// Turn off</span>
    <span class="hljs-built_in">digitalWrite</span>(r_dir_port, LOW);
  }
}

<span class="hljs-comment">// Set direction of the motors</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setLeftDir</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span> </span>{
  <span class="hljs-keyword">if</span> (dir == BACKWARD) {
    inverts_and_states |= LEFT_DIR_MASK;  <span class="hljs-comment">// Turn on</span>
    <span class="hljs-built_in">digitalWrite</span>(l_dir_port, HIGH);
  } <span class="hljs-keyword">else</span> {
    inverts_and_states &amp;= ~LEFT_DIR_MASK;  <span class="hljs-comment">// Turn off</span>
    <span class="hljs-built_in">digitalWrite</span>(l_dir_port, LOW);
  }
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Drive::isLeftInverted</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> inverts_and_states &amp; LEFT_INVERT_MASK; }

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Drive::isRightInverted</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> inverts_and_states &amp; RIGHT_INVERT_MASK; }

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Drive::leftDir</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> inverts_and_states &amp; LEFT_DIR_MASK; }

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Drive::rightDir</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> inverts_and_states &amp; RIGHT_DIR_MASK; }

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setGyroInit</span><span class="hljs-params">()</span> </span>{ inverts_and_states |= GYRO_INIT_MASK; }

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Drive::getGyroInit</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> inverts_and_states &amp; GYRO_INIT_MASK; }

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setLeftInverted</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> inverted)</span> </span>{
  <span class="hljs-keyword">if</span> (inverted == BACKWARD) {
    inverts_and_states |= LEFT_INVERT_MASK;  <span class="hljs-comment">// Turn on invert</span>
  } <span class="hljs-keyword">else</span> {
    inverts_and_states &amp;= ~LEFT_INVERT_MASK;  <span class="hljs-comment">// Turn off invert</span>
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setRightInverted</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> inverted)</span> </span>{
  <span class="hljs-keyword">if</span> (inverted == BACKWARD) {
    inverts_and_states |= RIGHT_INVERT_MASK;  <span class="hljs-comment">// Turn on invert</span>
  } <span class="hljs-keyword">else</span> {
    inverts_and_states &amp;= ~RIGHT_INVERT_MASK;  <span class="hljs-comment">// Turn off invert</span>
  }
}

<span class="hljs-comment">// Set left power between -128 and 127</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setLeftPower</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> power)</span> </span>{
  <span class="hljs-comment">// Make motor go forward with positive power, or backward if it&#x27;s negative</span>
  <span class="hljs-comment">// power</span>
  <span class="hljs-keyword">if</span> (power &gt;= <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isLeftInverted</span>()) {
      <span class="hljs-built_in">setLeftDir</span>(BACKWARD);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">setLeftDir</span>(FORWARD);
    }
  }
  <span class="hljs-comment">// Power is negative, change direction of the motor</span>
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isLeftInverted</span>()) {
      <span class="hljs-built_in">setLeftDir</span>(FORWARD);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">setLeftDir</span>(BACKWARD);
    }
  }

  <span class="hljs-comment">// Set PWM power, converting the negative/positive range into a 0-255 output</span>
  <span class="hljs-comment">// Input is between -127 to 128, which shows direction and magnitude</span>
  <span class="hljs-comment">// Want the power to be between 0 to 255, so multiply abs(input) by 2</span>
  <span class="hljs-built_in">analogWrite</span>(l_en_port, <span class="hljs-built_in">uint8_t</span>(((<span class="hljs-built_in">abs</span>(power)) &lt;&lt; <span class="hljs-number">1</span>) * LEFT_SCALAR));
}

<span class="hljs-comment">// Set right power between -128 and 127</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setRightPower</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> power)</span> </span>{
  <span class="hljs-comment">// Make motor go forward with positive power, or backward if it&#x27;s negative</span>
  <span class="hljs-comment">// power</span>
  <span class="hljs-keyword">if</span> (power &gt;= <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isRightInverted</span>()) {
      <span class="hljs-built_in">setRightDir</span>(BACKWARD);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">setRightDir</span>(FORWARD);
    }
  }
  <span class="hljs-comment">// Power is negative, change direction of the motor</span>
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isRightInverted</span>()) {
      <span class="hljs-built_in">setRightDir</span>(FORWARD);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">setRightDir</span>(BACKWARD);
    }
  }

  <span class="hljs-comment">// Set PWM power, converting the negative/positive range into a 0-255 output</span>
  <span class="hljs-comment">// Input is between -127 to 128, which shows direction and magnitude</span>
  <span class="hljs-comment">// Want the power to be between 0 to 255, so multiply abs(input) by 2</span>
  <span class="hljs-built_in">analogWrite</span>(r_en_port, <span class="hljs-built_in">uint8_t</span>(((<span class="hljs-built_in">abs</span>(power)) &lt;&lt; <span class="hljs-number">1</span>) * RIGHT_SCALAR));
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::stopMotors</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">setRightPower</span>(<span class="hljs-number">0</span>);
  <span class="hljs-built_in">setLeftPower</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Drive::getAngle</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getGyroInit</span>()) {
    <span class="hljs-type">double</span> yaw =
        gyro.<span class="hljs-built_in">getVector</span>(Adafruit_BNO055::VECTOR_EULER).<span class="hljs-built_in">x</span>() - gyro_offset;

    <span class="hljs-comment">// Get a range from [0, 360.0) with offset (if offset is 50, want 0 (-50) to</span>
    <span class="hljs-comment">// now map to 310.0)</span>
    <span class="hljs-keyword">if</span> (yaw &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> yaw + GYRO_DEGREES;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> yaw;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// Error, gyro not initialized</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setGyroOffset</span><span class="hljs-params">(<span class="hljs-type">double</span> offset)</span> </span>{
  gyro_offset = offset;  <span class="hljs-comment">// Can be used so 0 is always when the robot IR sensor</span>
                         <span class="hljs-comment">// is facing the beacon</span>
}

<span class="hljs-comment">/**
 * Get the turn error (to use for PID turning), limited from -180 to 180.
 * @param target_angle should be between 0 and 359 (absolute target), but can be between [-360.0, inf)
*/</span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Drive::calcTurnError</span><span class="hljs-params">(<span class="hljs-type">double</span> target_angle)</span> </span>{
  <span class="hljs-comment">// Normalize the target angle</span>
  <span class="hljs-keyword">if</span> (target_angle &gt; GYRO_DEGREES) {
    target_angle = <span class="hljs-built_in">fmod</span>(target_angle, GYRO_DEGREES);
  <span class="hljs-comment">// fmod doesn&#x27;t work the way I want it to with negatives (remainder still negative), so this is a way of fixing angles between -360.0 and 0</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target_angle &lt; <span class="hljs-number">0</span>) {
    target_angle += GYRO_DEGREES;
  }

  <span class="hljs-type">double</span> error = target_angle - <span class="hljs-built_in">getAngle</span>();
  <span class="hljs-keyword">if</span> (error &gt; GYRO_HALF_DEGREES) {
    error -= GYRO_DEGREES;
  }
  <span class="hljs-keyword">return</span> error;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::setTurnPIDPowers</span><span class="hljs-params">(<span class="hljs-type">double</span> target_angle, <span class="hljs-type">double</span> k_p)</span> </span>{
  <span class="hljs-type">double</span> error = <span class="hljs-built_in">calcTurnError</span>(target_angle);
  <span class="hljs-type">double</span> product = error * k_p;
  <span class="hljs-comment">// Cap powers to max inputs</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(product) &gt; INT8_MAX) {
    product = <span class="hljs-built_in">copysign</span>(INT8_MAX, product);
  }
  <span class="hljs-built_in">setLeftPower</span>(product);
  <span class="hljs-built_in">setRightPower</span>(-product);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Drive::printDebug</span><span class="hljs-params">()</span> </span>{
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gyro angle: &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">getAngle</span>());
}

</code></pre>
<h2 id="hopper">Hopper</h2>
<h3 id="hopperh">Hopper.h</h3>
<pre><code class="language-cpp"><span class="hljs-comment">/**
 * Wrapper for the hopper subsystem, allows user to drop x number of balls
*/</span>

<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> Hopper_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> Hopper_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Servo.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Hopper</span> {
  <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Hopper</span>(); <span class="hljs-comment">// Only to initialize at first</span>
    <span class="hljs-built_in">Hopper</span>(Servo &amp;servo, <span class="hljs-type">uint8_t</span> servo_port);
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">NOTE:</span> These functions use delay to get the correct timing (not the best practice)
    */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dropTwoBalls</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dropAllBalls</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInitialized</span><span class="hljs-params">()</span></span>;
  <span class="hljs-keyword">private</span>:
    Servo _servo;
    <span class="hljs-type">bool</span> _is_attached;
};

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

</code></pre>
<h3 id="hoppercpp">Hopper.cpp</h3>
<pre><code class="language-cpp"><span class="hljs-comment">/**
 * Hopper subsystem wrapper
 */</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Arduino.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Hopper.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_ANGLE 180</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DROP_ANGLE 135</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DROP_ONE_TIME 175 <span class="hljs-comment">// Was 125 before servo change</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DROP_ALL_TIME 700</span>

Hopper::<span class="hljs-built_in">Hopper</span>() { _is_attached = <span class="hljs-literal">false</span>; }

Hopper::<span class="hljs-built_in">Hopper</span>(Servo &amp;servo, <span class="hljs-type">uint8_t</span> servo_port) {
  _servo = servo;
  _servo.<span class="hljs-built_in">attach</span>(servo_port);
  _servo.<span class="hljs-built_in">write</span>(DEFAULT_ANGLE);
  _is_attached = <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hopper::dropTwoBalls</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (_is_attached) {
    _servo.<span class="hljs-built_in">write</span>(DROP_ANGLE);
    <span class="hljs-built_in">delay</span>(DROP_ONE_TIME);
    _servo.<span class="hljs-built_in">write</span>(DEFAULT_ANGLE);
  } <span class="hljs-keyword">else</span> {
    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Servo not attached!&quot;</span>);
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hopper::dropAllBalls</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (_is_attached) {
    _servo.<span class="hljs-built_in">write</span>(DROP_ANGLE);
    <span class="hljs-built_in">delay</span>(DROP_ALL_TIME);
    _servo.<span class="hljs-built_in">write</span>(DEFAULT_ANGLE);
  } <span class="hljs-keyword">else</span> {
    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Servo not attached!&quot;</span>);
  }
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Hopper::isInitialized</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> _is_attached;
}
</code></pre>
<h2 id="line-follow">Line Follow</h2>
<h3 id="linefollowh">LineFollow.h</h3>
<pre><code class="language-cpp"><span class="hljs-comment">/**
 * LineFollow.h defines all of the exposed methods for the line following subsystem, including using its five tape sensors
*/</span>

<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LineFollow_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LineFollow_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;LineDataTypes.h&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LineFollow</span> {
  <span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/**
     * Pass in the ports for the tape sensors on the robot
    */</span>
    <span class="hljs-built_in">LineFollow</span>(<span class="hljs-type">uint8_t</span> left_wing, <span class="hljs-type">uint8_t</span> line_left, <span class="hljs-type">uint8_t</span> line_right,
                       <span class="hljs-type">uint8_t</span> right_wing, Line_thresholds_t thresholds); 
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">testForBlackTape</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">testForLeftWingBlack</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// added ESL</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">testForRightWingBlack</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// added ESL</span>
    <span class="hljs-comment">/**
     * Check if the left wing sees red tape (given max value for white, and min value for black tape)
    */</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">testForLeftWingRed</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">/**
     * Check if the left wing sees either red or black tape
    */</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">testForRightWingRed</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">/**
     * Get the error for PID line follow, given the difference between the center and right/left wings when the robot is centered over the line
    */</span>
    <span class="hljs-function">Motor_powers_t <span class="hljs-title">getLineFollowPowers</span><span class="hljs-params">(<span class="hljs-type">double</span> k_p, <span class="hljs-type">int8_t</span> base_power)</span></span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add P for smoother line follow</span>
    <span class="hljs-comment">/**
     * Check that any of the line sensors (middle 3) are on the line
    */</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">testForOnLine</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDebug</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setThresholds</span><span class="hljs-params">(Line_thresholds_t thresholds)</span></span>;
    <span class="hljs-function">Line_sensor_vals_t <span class="hljs-title">LineFollow::getSensorReadings</span><span class="hljs-params">()</span></span>;

  <span class="hljs-keyword">private</span>:
    <span class="hljs-type">uint8_t</span> _left_wing;
    <span class="hljs-type">uint8_t</span> _line_left;
    <span class="hljs-type">uint8_t</span> _line_right;
    <span class="hljs-type">uint8_t</span> _right_wing;
    Line_thresholds_t _thresholds;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isRed</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> sensor_value, <span class="hljs-type">uint16_t</span> min_white,
                       <span class="hljs-type">uint16_t</span> max_red, <span class="hljs-type">uint16_t</span> max_black)</span></span>;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBlack</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> sensor_value, <span class="hljs-type">uint16_t</span> max_red)</span></span>;

};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<h3 id="linefollowcpp">LineFollow.cpp</h3>
<pre><code class="language-cpp"><span class="hljs-comment">/**
 * LineFollow.cpp is the class for using 5 tape sensors to follow a line and
 * detect intersections
 */</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LineFollow.h&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Arduino.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> RED_BLACK_WIGGLE_ROOM 125 <span class="hljs-comment">// Was 150, then 125 (now that red tape is 370) // was 100 before comp ESL</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SENSOR_NOISE 3 <span class="hljs-comment">// Was 20, then 10 </span></span>

LineFollow::<span class="hljs-built_in">LineFollow</span>(<span class="hljs-type">uint8_t</span> left_wing, <span class="hljs-type">uint8_t</span> line_left, <span class="hljs-type">uint8_t</span> line_right,
                       <span class="hljs-type">uint8_t</span> right_wing, Line_thresholds_t thresholds) {
  _left_wing = left_wing;
  _line_left = line_left;
  _line_right = line_right;
  _right_wing = right_wing;
  _thresholds = thresholds;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LineFollow::setThresholds</span><span class="hljs-params">(Line_thresholds_t thresholds)</span> </span>{
  _thresholds = thresholds;
}

<span class="hljs-function">Line_sensor_vals_t <span class="hljs-title">LineFollow::getSensorReadings</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> {<span class="hljs-built_in">analogRead</span>(_left_wing), <span class="hljs-built_in">analogRead</span>(_right_wing),
          <span class="hljs-built_in">analogRead</span>(_line_left), <span class="hljs-built_in">analogRead</span>(_line_right)};
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::testForBlackTape</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Check if any of the sensors detect black tape</span>
  <span class="hljs-type">bool</span> lw_black = <span class="hljs-built_in">isBlack</span>(<span class="hljs-built_in">analogRead</span>(_left_wing), _thresholds.max_lw_red);
  <span class="hljs-comment">// bool ll_black = isBlack(analogRead(_line_left), _thresholds.max_ll_red);</span>
  <span class="hljs-comment">// bool lr_black = isBlack(analogRead(_line_right), _thresholds.max_lr_red);</span>
  <span class="hljs-type">bool</span> rw_black = <span class="hljs-built_in">isBlack</span>(<span class="hljs-built_in">analogRead</span>(_right_wing), _thresholds.max_rw_red);

  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Only for testing</span>
  <span class="hljs-comment">// if (lw_black) {</span>
  <span class="hljs-comment">//   Serial.println(&quot;Left wing black&quot;);</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-comment">// if (ll_black) {</span>
  <span class="hljs-comment">//   Serial.println(&quot;Line left black&quot;);</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-comment">// if (lr_black) {</span>
  <span class="hljs-comment">//   Serial.println(&quot;Line right black&quot;);</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-comment">// if (rw_black) {</span>
  <span class="hljs-comment">//   Serial.println(&quot;Right wing black&quot;);</span>
  <span class="hljs-comment">// }</span>


  <span class="hljs-keyword">return</span> rw_black;
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::testForLeftWingBlack</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// ESL</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBlack</span>(<span class="hljs-built_in">analogRead</span>(_left_wing), _thresholds.max_lw_red);
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::testForRightWingBlack</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// ESL</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBlack</span>(<span class="hljs-built_in">analogRead</span>(_right_wing), _thresholds.max_rw_red);
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::testForLeftWingRed</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">isRed</span>(<span class="hljs-built_in">analogRead</span>(_left_wing), _thresholds.min_lw_white,
               _thresholds.max_lw_red, _thresholds.max_lw_black);
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::testForRightWingRed</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">isRed</span>(<span class="hljs-built_in">analogRead</span>(_right_wing), _thresholds.min_rw_white,
               _thresholds.max_rw_red, _thresholds.max_rw_black);
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::testForOnLine</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-type">bool</span> is_left_red = <span class="hljs-built_in">isRed</span>(<span class="hljs-built_in">analogRead</span>(_line_left), _thresholds.min_ll_white,
                           _thresholds.max_ll_red, _thresholds.max_ll_black);
  <span class="hljs-type">bool</span> is_right_red = <span class="hljs-built_in">isRed</span>(<span class="hljs-built_in">analogRead</span>(_line_right), _thresholds.min_lr_white,
                            _thresholds.max_lr_red, _thresholds.max_lr_black);
  <span class="hljs-keyword">return</span> is_left_red || is_right_red;
}

<span class="hljs-function">Motor_powers_t <span class="hljs-title">LineFollow::getLineFollowPowers</span><span class="hljs-params">(<span class="hljs-type">double</span> k_p, <span class="hljs-type">int8_t</span> base_power)</span> </span>{
  <span class="hljs-type">uint16_t</span> left_value = <span class="hljs-built_in">analogRead</span>(_line_left);
  <span class="hljs-type">uint16_t</span> right_value = <span class="hljs-built_in">analogRead</span>(_line_right) + <span class="hljs-number">1</span>;

  <span class="hljs-type">int16_t</span> error = left_value - right_value;
  <span class="hljs-comment">// double pid_output = error * k_p;</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(error) &lt; SENSOR_NOISE) {
    <span class="hljs-keyword">return</span> {(base_power &gt;&gt; <span class="hljs-number">2</span>) * <span class="hljs-number">3</span>, (base_power &gt;&gt; <span class="hljs-number">2</span>) * <span class="hljs-number">3</span>}; <span class="hljs-comment">// Fast 7/8 power for straight line (&gt;&gt; 3 for /8, * 7 for 7/8)</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_value &gt; (left_value + SENSOR_NOISE)) {
    <span class="hljs-comment">// Turn right</span>
    <span class="hljs-keyword">return</span> {base_power, <span class="hljs-number">0</span>};
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Turn left</span>
    <span class="hljs-comment">// If left value more than right value, it is more red, therefore, turn left</span>
    <span class="hljs-keyword">return</span> {<span class="hljs-number">0</span>, base_power};
  }
  
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::isRed</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> sensor_value, <span class="hljs-type">uint16_t</span> min_white,
                       <span class="hljs-type">uint16_t</span> max_red, <span class="hljs-type">uint16_t</span> max_black)</span> </span>{
  <span class="hljs-type">uint16_t</span> max_white = (min_white + max_red) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// Divide by 2 for average</span>
  <span class="hljs-type">uint16_t</span> min_black = (max_red + RED_BLACK_WIGGLE_ROOM);
  <span class="hljs-keyword">return</span> (sensor_value &gt; max_white) &amp;&amp; (sensor_value &lt; min_black);
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LineFollow::isBlack</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> sensor_value, <span class="hljs-type">uint16_t</span> max_red)</span> </span>{
  <span class="hljs-keyword">return</span> sensor_value &gt; (max_red + RED_BLACK_WIGGLE_ROOM);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LineFollow::printDebug</span><span class="hljs-params">()</span> </span>{
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LW: &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">analogRead</span>(_left_wing));
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LineL: &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">analogRead</span>(_line_left));
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LineR: &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">analogRead</span>(_line_right));
  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;RW: &quot;</span>);
  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">analogRead</span>(_right_wing));
}
</code></pre>
<h3 id="linedatatypesh">LineDataTypes.h</h3>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LineDataTypes_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LineDataTypes_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
  <span class="hljs-type">int8_t</span> left_power;
  <span class="hljs-type">int8_t</span> right_power;
} Motor_powers_t;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
  <span class="hljs-type">uint16_t</span> min_lw_white;
  <span class="hljs-type">uint16_t</span> max_lw_red;
  <span class="hljs-type">uint16_t</span> max_lw_black;

  <span class="hljs-type">uint16_t</span> min_ll_white;
  <span class="hljs-type">uint16_t</span> max_ll_red;
  <span class="hljs-type">uint16_t</span> max_ll_black;

  <span class="hljs-type">uint16_t</span> min_lr_white;
  <span class="hljs-type">uint16_t</span> max_lr_red;
  <span class="hljs-type">uint16_t</span> max_lr_black;

  <span class="hljs-type">uint16_t</span> min_rw_white;
  <span class="hljs-type">uint16_t</span> max_rw_red;
  <span class="hljs-type">uint16_t</span> max_rw_black;
} Line_thresholds_t;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
  <span class="hljs-type">uint16_t</span> lw;
  <span class="hljs-type">uint16_t</span> ll;
  <span class="hljs-type">uint16_t</span> lr;
  <span class="hljs-type">uint16_t</span> rw;
} Line_sensor_vals_t;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<h1 id="bill-of-materials">Bill of Materials</h1>
<p><img src="file:////Users/jamesvarah/Desktop/School/Sophomore Year/Winter 2023/ME210/ME210-final-project/final-report/BOM.png" alt="BOM"></p>

        
        
    </body>
    </html>